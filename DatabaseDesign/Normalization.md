
# Database Design Notes

### Keys in database
---

## 1. Primary Key
- **Description**: A unique identifier for each record in a table.
- **Condition**: Cannot be NULL, and must contain unique values.
- **Use**: Ensures each record is unique, and helps establish relationships with foreign keys.
- **Example**: In a `Users` table, `user_id` can be the primary key.

### SQL Example
```
CREATE TABLE Users (
    user_id INT PRIMARY KEY,
    username VARCHAR(50),
    email VARCHAR(100)
);

```
## 2. Foreign Key
**Description**: A key used to link two tables together.
**Condition**: Refers to a primary key in another table; it can contain NULL values.
**Use**: Enforces referential integrity between two related tables.
**Example**: In an Orders table, user_id could be a foreign key referencing the Users table.

```
CREATE TABLE Orders (
    order_id INT PRIMARY KEY,
    order_date DATE,
    user_id INT,
    FOREIGN KEY (user_id) REFERENCES Users(user_id)
);

```
## 3. Candidate Key
**Description**: A minimal set of attributes that can uniquely identify a record in a table.
**Condition**: Must be unique and minimal (no unnecessary attributes).
**Use**: One of the candidate keys is chosen as the primary key.
**Example**: In a Students table, both student_id and email could serve as candidate keys.

## 4. Composite Key
**Description**: A key consisting of two or more columns to uniquely identify a record.
**Condition**: Combination of columns must be unique together.
**Use**: Used when a single column is not sufficient to uniquely identify records.
**Example**: In an Enrollments table, student_id and course_id together could form a composite key.
```
CREATE TABLE Enrollments (
    student_id INT,
    course_id INT,
    enrollment_date DATE,
    PRIMARY KEY (student_id, course_id)
);
```
## 5. Alternate Key
**Description**: Candidate keys that are not chosen as the primary key.
**Condition**: Unique and can serve as a primary key if needed.
**Use**: Acts as a backup identifier for records.
**Example**: In the Students table, if student_id is the primary key, email is an alternate key.

## 6. Super Key
**Description**: A set of one or more columns that can uniquely identify a row in a table.
**Condition**: Can include extra attributes beyond what's necessary to ensure uniqueness.
**Use**: Identifies potential candidate keys.
**Example**: In the Employees table, employee_id and (employee_id, email) are both super keys.

## 7. Unique Key
**Description**: Ensures that all values in a column are unique.
**Condition**: Can accept one NULL value.
**Use**: Enforces data uniqueness for columns that are not primary keys.
**Example**: In the Products table, product_code can be a unique key.
```
CREATE TABLE Products (
    product_id INT PRIMARY KEY,
    product_name VARCHAR(100),
    product_code VARCHAR(20) UNIQUE
);

```
## 8. Surrogate Key
**Description**: A unique identifier for each row, usually generated by the database (e.g., auto-increment).
**Condition**: Not derived from application data.
**Use**: Adds an artificial identifier to a table.
**Example**: In Orders, an auto-incremented order_id can serve as a surrogate key.

```
CREATE TABLE Orders (
    order_id INT AUTO_INCREMENT PRIMARY KEY,
    order_date DATE,
    customer_name VARCHAR(50)
);
```
## 9. Secondary Key
**Description**: Non-primary key used for indexing to improve query performance.
**Condition**: Can include non-unique columns.
**Use**: Optimizes search and retrieval.
**Example**: In the Employees table, department_id can be a secondary key to quickly search employees by department.
```CREATE INDEX idx_department ON Employees(department_id); 
```

## Duplicacy in Databases

### Problem
Duplicacy in databases can lead to inefficiencies and data integrity issues. Duplicacy may occur at:
- **Row Level Duplicacy**: Entire rows of data are repeated, leading to redundant entries.
- **Column Level Duplicacy**: Information is stored in multiple columns unnecessarily, which can result in redundancy and increased storage requirements.

These duplicacies cause issues known as:
- **Insertion Anomaly**: Problems arise when adding new data due to duplicacy or unnecessary dependencies.
- **Deletion Anomaly**: Unintended data loss occurs when deleting data from a table.
- **Update Anomaly**: Updating duplicated data becomes difficult as it requires multiple updates across the database.

### Examples of Anomalies

#### Insertion Anomaly
Consider a `Students` table with columns `Student_ID`, `Student_Name`, and `Course`. If a new course must be added but there is no student enrolled yet, an `Insertion Anomaly` occurs as we may need to leave certain fields empty or create incomplete entries.

| Student_ID | Student_Name | Course     |
|------------|--------------|------------|
| 1          | Raj          | Math       |
| 2          | Priya        | Science    |
| NULL       | NULL         | History    |  ← Issue: no student for History course

#### Deletion Anomaly
If a student `Priya` (Student_ID = 2) is deleted from the table, we lose information about her `Science` course as well. Thus, deletion of one data point inadvertently deletes related information, leading to `Deletion Anomaly`.

| Student_ID | Student_Name | Course     |
|------------|--------------|------------|
| 1          | Raj          | Math       |
| 2          | Priya        | Science    | ← If deleted, information about Science course is lost

#### Update Anomaly
In a table where a teacher’s name is stored multiple times (one entry per course), changing the teacher’s name for one course doesn’t reflect in all entries, leading to inconsistent data. For example, changing `Mr. Sharma` to `Dr. Sharma` would require multiple updates.

| Course_ID | Course_Name | Teacher     |
|-----------|-------------|-------------|
| 101       | Math        | Mr. Sharma  |
| 102       | Science     | Mr. Sharma  | ← Needs update to Dr. Sharma
| 103       | English     | Ms. Kapoor  |

---

## 1st Normal Form (1NF)

### Problem
1NF solves the problem of unorganized data and repeating groups in a table. It ensures that each column contains atomic values, and each column stores values of a single type.

### Solution
In 1NF, we organize data so that every field contains only a single value.

### Example
Suppose we have a `Students` table:

| Student_ID | Name       | Courses                |
|------------|------------|------------------------|
| 1          | Raj        | Math, Science          |
| 2          | Priya      | Math, English, Science |

This table is not in 1NF because `Courses` column contains multiple values. 

To convert it to 1NF:

| Student_ID | Name       | Course     |
|------------|------------|------------|
| 1          | Raj        | Math       |
| 1          | Raj        | Science    |
| 2          | Priya      | Math       |
| 2          | Priya      | English    |
| 2          | Priya      | Science    |

---

## 2nd Normal Form (2NF)

### Problem
2NF eliminates partial dependency where non-prime attributes depend on only a part of a composite primary key. It helps reduce data redundancy further.

### Solution
To achieve 2NF, ensure the table is in 1NF and that no non-prime attribute is partially dependent on any candidate key.

### Example
Consider a `Student_Courses` table:

| Student_ID | Course_ID | Student_Name | Course_Name | Teacher     |
|------------|-----------|--------------|-------------|-------------|
| 1          | 101       | Raj          | Math        | Mr. Sharma  |
| 1          | 102       | Raj          | Science     | Dr. Verma   |
| 2          | 101       | Priya        | Math        | Mr. Sharma  |
| 2          | 103       | Priya        | English     | Ms. Kapoor  |

This table is not in 2NF because `Student_Name` depends only on `Student_ID`, and `Course_Name` & `Teacher` depend only on `Course_ID`.

In 2NF, we split the table:

1. **Students Table**

| Student_ID | Student_Name |
|------------|--------------|
| 1          | Raj          |
| 2          | Priya        |

2. **Courses Table**

| Course_ID | Course_Name | Teacher     |
|-----------|-------------|-------------|
| 101       | Math        | Mr. Sharma  |
| 102       | Science     | Dr. Verma   |
| 103       | English     | Ms. Kapoor  |

3. **Enrollment Table** (Links Students and Courses)

| Student_ID | Course_ID |
|------------|-----------|
| 1          | 101       |
| 1          | 102       |
| 2          | 101       |
| 2          | 103       |

---

## Functional Dependency

### Problem
Functional dependency ensures data integrity by establishing relationships between attributes so that data is uniquely identifiable.

### Solution
Define dependencies such that knowing a certain attribute allows us to uniquely identify other related attributes.

### Example
In a `Students` table:

| Roll_Number | Name       | Class |
|-------------|------------|-------|
| 1           | Raj        | 10th  |
| 2           | Priya      | 10th  |

`Roll_Number -> Name` means knowing `Roll_Number` uniquely determines `Name`.

---

## Closure of Attribute Sets

### Problem
Closure helps in finding all attributes functionally determined by a given set of attributes. It’s essential in identifying candidate keys.

### Solution
For a given attribute set, use known functional dependencies to find all attributes determined by it.

### Example
Given dependencies:
- `A -> B`
- `B -> C`

To find closure of `{A}`, we can derive `{A, B, C}`.

---

This document summarizes key concepts in database normalization and design with examples to illustrate how normalization steps reduce redundancy and ensure data integrity.

## 3rd Normal Form (3NF)

### Problem
3NF ka kaam hai **transitive dependency** ko eliminate karna. Transitive dependency tab hoti hai jab ek non-prime attribute (wo attribute jo primary key nahi hai) indirectly kisi aur attribute pe depend ho. Transitive dependency ki wajah se data redundancy aur anomalies aur bhi badh jati hain, jo data consistency aur integrity ke liye khatarnaak hota hai.

### Solution
3NF achieve karne ke liye:
1. Pehle table ko 2NF mein convert karna zaroori hai (yaani ki partial dependencies ko eliminate karna).
2. Phir ensure karo ki kisi bhi non-prime attribute ka dependency sirf aur sirf candidate key par hi ho, aur kisi bhi non-prime attribute ka dependency kisi aur non-prime attribute par na ho.

Iska simple rule ye hai: **"All non-key attributes must depend only on the primary key aur kisi aur non-key attribute pe nahi."**

### Example
Maan lo humare paas ek `Employee` table hai:

| Emp_ID | Emp_Name | Dept_ID | Dept_Name | Manager   |
|--------|----------|---------|-----------|-----------|
| 1      | Raj      | 101     | Sales     | Mr. Verma |
| 2      | Priya    | 102     | HR        | Ms. Gupta |
| 3      | Amit     | 101     | Sales     | Mr. Verma |

Is table mein:
- `Emp_ID` ek unique key hai.
- `Dept_Name` aur `Manager` ka dependency directly `Dept_ID` pe hai, na ki `Emp_ID` pe, jo ek transitive dependency create karta hai. 

#### 3NF mein Conversion
Ab, table ko 3NF mein convert karte hain, hum is table ko do tables mein divide karenge:

1. **Employee Table**
   
| Emp_ID | Emp_Name | Dept_ID |
|--------|----------|---------|
| 1      | Raj      | 101     |
| 2      | Priya    | 102     |
| 3      | Amit     | 101     |

2. **Department Table**

| Dept_ID | Dept_Name | Manager   |
|---------|-----------|-----------|
| 101     | Sales     | Mr. Verma |
| 102     | HR        | Ms. Gupta |

Ab:
- `Employee` table mein `Emp_ID` se hum `Emp_Name` aur `Dept_ID` ka relationship maintain kar rahe hain.
- `Department` table mein har `Dept_ID` se `Dept_Name` aur `Manager` ka relationship maintain ho raha hai.

#### Benefits
Is conversion ke baad:
1. **Data Redundancy** reduce ho gayi, kyunki `Dept_Name` aur `Manager` ke liye hume repeat nahi karna pad raha.
2. **Update Anomalies** fix ho gayi hain, kyunki agar `Dept_Name` ya `Manager` change hota hai, toh hume sirf `Department` table mein change karna hai.
3. **Data Integrity** maintain ho rahi hai, aur koi **transitive dependency** nahi hai.

---

## Boyce-Codd Normal Form (BCNF)

### Problem
BCNF ka main kaam hai **candidate key dependency anomalies** ko solve karna. BCNF 3NF se bhi ek kadam aage hai aur wo tables mein bachi hui dependency issues ko fix karta hai jo 3NF mein bhi reh sakti hain. Yeh specially tab useful hota hai jab tables mein multiple candidate keys ho aur unmein kuch dependency issues ho jayein.

BCNF mein ek additional rule hai: **"Agar koi non-trivial functional dependency A → B hai, toh A ek superkey hona chahiye."** Simple shabdon mein, **kisi bhi attribute ka dependency kisi bhi non-superkey pe nahi hona chahiye.**

### Solution
1. Pehle 3NF ka har rule apply karo, jisse transitive aur partial dependencies remove ho jayein.
2. Uske baad ensure karo ki har functional dependency mein, jo bhi determinant hai (left side wala attribute), wo superkey hai.

BCNF ka aim ye hai ki **sare non-superkey dependencies remove** ho jaayein, jo bacha-kucha redundancy remove kar deta hai.

### Example
Chalo ek example se samjhte hain. Maan lo ek `Student` table hai:

| Student_ID | Course   | Teacher   |
|------------|----------|-----------|
| 1          | Math     | Mr. Sharma|
| 2          | Science  | Ms. Verma |
| 3          | Math     | Mr. Sharma|
| 4          | Science  | Ms. Verma |

Is table mein:
- `Student_ID` ek unique key hai.
- Lekin yahan dependency issue hai kyunki `Course` ka dependency `Teacher` pe hai, aur `Course` aur `Teacher` dono mil ke ek unique pairing banate hain.

#### BCNF mein Conversion
Ab, table ko BCNF mein convert karte hain. BCNF achieve karne ke liye hum do tables banayenge:

1. **Student Course Table**

| Student_ID | Course   |
|------------|----------|
| 1          | Math     |
| 2          | Science  |
| 3          | Math     |
| 4          | Science  |

2. **Course Teacher Table**

| Course   | Teacher   |
|----------|-----------|
| Math     | Mr. Sharma|
| Science  | Ms. Verma |

Ab:
- `Student Course` table mein `Student_ID` aur `Course` ka direct relationship hai.
- `Course Teacher` table mein `Course` aur `Teacher` ka unique relationship maintain ho raha hai.

#### Benefits
Is conversion ke baad:
1. **Data Redundancy** kam ho gayi hai, kyunki ab `Course` aur `Teacher` ka relationship ek alag table mein hai.
2. **Update Anomalies** eliminate ho gayi hain, kyunki agar kisi course ka teacher change hota hai, toh sirf `Course Teacher` table mein change karna padega.
3. **Data Integrity** ensure ho gayi hai, aur ab har functional dependency BCNF ke rules follow kar rahi hai.

---
